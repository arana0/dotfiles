#!/bin/bash     行頭,「このシェルスクリプトは bash によって解釈・実行されます」と、宣言するためのもの,必ず1行目

条件式には [ コマンドを使用する,前後には必ずスペースが必要になる
;は同一行に複数コマンドを記述する場合に区切りとして使用する

read str    : readコマンドでキーボードから入力した文字列を変数strに設定する

文字列結合
valueA="valueA"
valueB="valueB"
これらをつなげたいとすると、
value=$valueA$valueB
宣言されている変数は"$"で囲む（strの場合は"$str"）
決まった文字列にはワイルドカード (すべての文字列と一致の「*」と、任意の一文字と一致の「?」) が使用可能

条件分岐
if 条件式1 ; then
処理1
elif 条件式2 ; then
処理2
else
処理3
fi

無限ループ
while : 
do
処理
if [ 条件 ]; then
    # break コマンドでループを抜ける
    break
fi
done

条件
[ $a -eq n ]        aがnと等しいとき（数値）
[ "$s" = "string" ] sがstringと等しいとき（文字列）

コマンドライン引数を使うとき
#$      実行時に指定された引数の数を表す変数
$1～$n  シェルスクリプト実行時に指定した引数の値がそれぞれ設定される変数

gnuplot <<EOF
:
:
:
EOF
などすれば、gnuplotを起動したのちに<<EOF～EOFで囲んだ部分はコマンドとして渡せる

shell scriptは「'」と「`」を見極めないとといけない
「"」（ダブルクォーテーション）     ：$以降は変数の中身を表示
「'」（シングルクォーテーション）   ：文字列はすべてそのまま表示
「`」（バッククォーテーション）     ：$以降は変数の中身を表示したものをコマンドとして実行

インクリメントの表記(++)
#宣言
i=1
#インクリメント
i=$((i+1))


set コマンドはタブや空白区切りの値を $1, $2, $3, ……に代入します。
IFS を変更することにより他の区切りに対応できます。
ex)
#!/bin/bash
TEXT='AAA,hoge,2345'
IFS=','         <- 区切り文字にカンマを指定
set -- $TEXT
echo $1
echo $2
echo $3

--はオプションの終わりを表し，それ以降のオプション処理を行わない

配列
array=()                空の配列生成
array=("a" "b" "c")     初期化しつつ配列作成
${#array[@]}            配列の要素数
array=(x "${array[@]}") 先頭にxを追加
array=("{array[@]}" x)  末尾に追加
C言語風に記述して中身を取り出す
for ((i = 0; i < ${#array[@]}; i++)) {
        echo "array[$i] = ${array[i]}"
}
unset array[@]：全削除する
